{
  "file_path": "docs/protocols/HELENA_VECTOR_1024_REQUIREMENT.md",
  "title": "\ud83c\udfaf OBOWI\u0104ZEK: Helena - Vectors 1024 Dimensions",
  "document_type": "architecture",
  "content": "# \ud83c\udfaf OBOWI\u0104ZEK: Helena - Vectors 1024 Dimensions\n\n**Data:** 2025-11-04  \n**Status:** OBOWI\u0104ZKOWY - MANDATORY  \n**Priority:** CRITICAL  \n**Autor:** System Architecture\n\n---\n\n## \u26a0\ufe0f WYM\u00d3G KRYTYCZNY\n\n**Helena MUSI u\u017cywa\u0107 vector\u00f3w o wymiarze 1024 dla wszystkich operacji z Qdrant!**\n\n### Dlaczego 1024?\n\nKolekcja `destiny-team-framework-master` w Qdrant jest skonfigurowana z:\n\n```json\n{\n  \"vectors\": {\n    \"size\": 1024,\n    \"distance\": \"Cosine\"\n  }\n}\n```\n\n**NIEZGODNO\u015a\u0106 WYMIAR\u00d3W = INDEXING FAILURE!**\n\n---\n\n## \ud83d\udccb ZASADY OBOWI\u0104ZKOWE\n\n### 1. Vector Generation - ZAWSZE 1024 wymiary\n\n```python\n# \u2705 POPRAWNE - 1024 wymiary\ndef generate_embedding(text: str) -> list:\n    \"\"\"Generate 1024-dimensional vector for Qdrant\"\"\"\n    hash_obj = hashlib.sha512(text.encode())\n    hash_bytes = hash_obj.digest()  # 64 bytes\n    \n    # Create 1024-dimensional vector\n    embedding = []\n    for i in range(1024):\n        byte_val = hash_bytes[i % len(hash_bytes)]\n        embedding.append((byte_val / 127.5) - 1.0)\n    \n    return embedding  # len(embedding) == 1024\n```\n\n```python\n# \u274c NIEPOPRAWNE - 384 wymiary (SHA-384)\nhash_obj = hashlib.sha384(text.encode())\nembedding = [(b / 127.5) - 1.0 for b in hash_obj.digest()]\n# len(embedding) == 48 \u274c B\u0141\u0104D!\n```\n\n### 2. Przed Indexowaniem - ZAWSZE Weryfikuj\n\n```python\n# OBOWI\u0104ZKOWA weryfikacja przed upsert\nif len(embedding) != 1024:\n    raise ValueError(f\"Vector must be 1024 dimensions, got {len(embedding)}\")\n\n# Dopiero potem index\nclient.upsert(\n    collection_name=\"destiny-team-framework-master\",\n    points=[PointStruct(id=doc_id, vector=embedding, payload=data)]\n)\n```\n\n### 3. Helena Processor - Wymagania\n\n**Ka\u017cdy Helena processor MUSI:**\n\n1. \u2705 Generowa\u0107 vectors 1024 wymiar\u00f3w\n2. \u2705 Weryfikowa\u0107 d\u0142ugo\u015b\u0107 przed indexowaniem\n3. \u2705 Logowa\u0107 wymiary w przypadku b\u0142\u0119du\n4. \u2705 Nie pr\u00f3bowa\u0107 indexowa\u0107 przy niezgodno\u015bci\n\n---\n\n## \ud83d\udd27 Implementacja w Helena Processors\n\n### helena_realtime_processor_simple.py\n\n```python\ndef add_to_qdrant(self, task_data: Dict, content: str) -> bool:\n    \"\"\"Index to Qdrant - WYMAGA 1024 wymiar\u00f3w\"\"\"\n    \n    # Generate 1024-dimensional embedding\n    embedding = self._generate_embedding_1024(content[:1000])\n    \n    # VERIFY dimension\n    if len(embedding) != 1024:\n        print(f\"   \u274c ERROR: Vector dimension mismatch! Expected 1024, got {len(embedding)}\")\n        return False\n    \n    # Safe to index\n    client.upsert(\n        collection_name=\"destiny-team-framework-master\",\n        points=[PointStruct(id=doc_id, vector=embedding, payload=data)]\n    )\n    \n    return True\n\ndef _generate_embedding_1024(self, text: str) -> list:\n    \"\"\"Generate EXACTLY 1024-dimensional vector\"\"\"\n    hash_obj = hashlib.sha512(text.encode())\n    hash_bytes = hash_obj.digest()\n    \n    embedding = []\n    for i in range(1024):\n        byte_val = hash_bytes[i % len(hash_bytes)]\n        embedding.append((byte_val / 127.5) - 1.0)\n    \n    assert len(embedding) == 1024, \"Vector MUST be 1024 dimensions!\"\n    return embedding\n```\n\n---\n\n## \ud83d\udeab CZ\u0118STE B\u0141\u0118DY - ZABRONIONE\n\n### \u274c B\u0142\u0105d 1: U\u017cywanie SHA-384 (48 bajt\u00f3w = 384 wymiary)\n\n```python\n# ZABRONIONE!\nhash_obj = hashlib.sha384(text.encode())\nembedding = [(b / 127.5) - 1.0 for b in hash_obj.digest()]\n# Rezultat: 48 wymiar\u00f3w \u274c\n```\n\n### \u274c B\u0142\u0105d 2: U\u017cywanie SHA-256 (32 bajty = 256 wymiar\u00f3w)\n\n```python\n# ZABRONIONE!\nhash_obj = hashlib.sha256(text.encode())\nembedding = [(b / 127.5) - 1.0 for b in hash_obj.digest()]\n# Rezultat: 32 wymiary \u274c\n```\n\n### \u274c B\u0142\u0105d 3: Brak weryfikacji\n\n```python\n# ZABRONIONE!\nembedding = generate_some_embedding(text)\nclient.upsert(points=[...])  # Nie sprawdzamy wymiaru!\n```\n\n---\n\n## \u2705 POPRAWNE PODEJ\u015aCIA\n\n### Opcja 1: SHA-512 z powt\u00f3rzeniem (Current)\n\n```python\nhash_obj = hashlib.sha512(text.encode())  # 64 bajty\nhash_bytes = hash_obj.digest()\n\nembedding = []\nfor i in range(1024):\n    byte_val = hash_bytes[i % 64]  # Powtarzamy cyklicznie\n    embedding.append((byte_val / 127.5) - 1.0)\n# Rezultat: 1024 wymiary \u2705\n```\n\n### Opcja 2: Prawdziwe Embeddings (Rekomendowane na przysz\u0142o\u015b\u0107)\n\n```python\n# Jina AI Embeddings (v3, 1024 dimensions)\nfrom jina import Client\nclient = Client(api_key=\"...\")\nembedding = client.encode([text])[0]  # 1024 wymiary \u2705\n```\n\n```python\n# Local Model (sentence-transformers)\nfrom sentence_transformers import SentenceTransformer\nmodel = SentenceTransformer('BAAI/bge-large-en-v1.5')  # 1024 dims\nembedding = model.encode(text).tolist()  # 1024 wymiary \u2705\n```\n\n---\n\n## \ud83d\udd0d Weryfikacja\n\n### Test 1: Sprawd\u017a wymiar vectora\n\n```python\ndef test_vector_dimension():\n    processor = HelenaRealtimeProcessor()\n    embedding = processor._generate_embedding_1024(\"test content\")\n    \n    assert len(embedding) == 1024, f\"Expected 1024, got {len(embedding)}\"\n    print(\"\u2705 Vector dimension: OK\")\n\ntest_vector_dimension()\n```\n\n### Test 2: Sprawd\u017a kolekcj\u0119 Qdrant\n\n```bash\ncurl -s http://localhost:6333/collections/destiny-team-framework-master \\\n  | python3 -c \"import json,sys; print('Vector size:', json.load(sys.stdin)['result']['config']['params']['vectors']['size'])\"\n\n# Expected output: Vector size: 1024\n```\n\n### Test 3: Indexing test\n\n```python\nfrom qdrant_client import QdrantClient\nclient = QdrantClient(url=\"http://localhost:6333\")\n\n# Test embedding\nembedding = [0.5] * 1024  # 1024 wymiar\u00f3w\n\ntry:\n    client.upsert(\n        collection_name=\"destiny-team-framework-master\",\n        points=[PointStruct(id=\"test\", vector=embedding, payload={})]\n    )\n    print(\"\u2705 Indexing successful - 1024 wymiar\u00f3w OK\")\nexcept Exception as e:\n    print(f\"\u274c Indexing failed: {e}\")\n```\n\n---\n\n## \ud83d\udcca Monitoring\n\n### Log Format dla Vector Operations\n\n```python\n# OBOWI\u0104ZKOWY format logowania\nprint(f\"\ud83d\udd0d Qdrant: Generating embedding...\")\nprint(f\"   \ud83d\udccf Vector dimensions: {len(embedding)}\")\nprint(f\"   \u2705 Dimension check: {'PASS' if len(embedding) == 1024 else 'FAIL'}\")\n\nif len(embedding) == 1024:\n    print(f\"   \u2705 INDEXED to Qdrant\")\nelse:\n    print(f\"   \u274c FAILED - Wrong dimension: {len(embedding)} (expected 1024)\")\n```\n\n### Metrics to Track\n\n1. **Vector Dimension Errors**: Count of indexing failures due to wrong dimensions\n2. **Successful Indexing**: Count of successful 1024-dim vector indexing\n3. **Dimension Distribution**: Histogram of attempted vector dimensions\n\n---\n\n## \ud83d\udea8 Error Handling\n\n### Gdy Vector != 1024\n\n```python\nif len(embedding) != 1024:\n    error_msg = f\"\"\"\n    CRITICAL ERROR: Vector Dimension Mismatch!\n    \n    Expected: 1024 dimensions\n    Got: {len(embedding)} dimensions\n    \n    Document: {task_data['file_path']}\n    \n    Action: Indexing ABORTED\n    Fix: Update embedding generation to produce 1024 dimensions\n    \"\"\"\n    \n    print(error_msg)\n    \n    # Save error report\n    error_file = f\"errors/vector_dim_error_{timestamp}.txt\"\n    Path(error_file).write_text(error_msg)\n    \n    # Do NOT attempt to index\n    return False\n```\n\n---\n\n## \ud83d\udccb Checklist dla Nowych Processors\n\nPrzed deploymentem nowego Helena processora:\n\n- [ ] Vector generation produces EXACTLY 1024 dimensions\n- [ ] Dimension verification before indexing\n- [ ] Error logging for dimension mismatches\n- [ ] Unit tests for vector dimension\n- [ ] Integration test with real Qdrant collection\n- [ ] Documentation updated with 1024 requirement\n\n---\n\n## \ud83c\udfaf Zgodno\u015b\u0107 z Architektur\u0105\n\n### Qdrant Collection Config\n\n```python\n# destiny-team-framework-master\nCOLLECTION_CONFIG = {\n    \"vectors\": {\n        \"size\": 1024,          # \u2190 WYM\u00d3G OBOWI\u0104ZKOWY\n        \"distance\": \"Cosine\"\n    }\n}\n```\n\n### Helena Config\n\n```python\n# Helena MUSI u\u017cywa\u0107 tej samej warto\u015bci\nHELENA_VECTOR_DIM = 1024  # \u2190 SYNCHRONIZACJA OBOWI\u0104ZKOWA\n\ndef validate_vector(embedding: list) -> bool:\n    \"\"\"Validate vector matches collection requirements\"\"\"\n    return len(embedding) == HELENA_VECTOR_DIM\n```\n\n---\n\n## \ud83d\udd04 Migration Path (je\u015bli potrzebna zmiana)\n\nJe\u015bli kiedykolwiek chcemy zmieni\u0107 wymiar vectora:\n\n1. **Utw\u00f3rz now\u0105 kolekcj\u0119** z nowym wymiarem\n2. **Zaktualizuj Helena processors** dla nowej kolekcji\n3. **Migruj dane** z starej do nowej kolekcji\n4. **Prze\u0142\u0105cz traffic** na now\u0105 kolekcj\u0119\n5. **Usu\u0144 star\u0105 kolekcj\u0119** po weryfikacji\n\n**NIE zmieniaj wymiaru w istniej\u0105cej kolekcji - to zniszczy wszystkie indexed vectors!**\n\n---\n\n## \u2705 Status: OBOWI\u0104ZKOWY\n\n**Ka\u017cdy Helena processor od teraz MUSI:**\n\n1. \u2705 Generowa\u0107 vectors 1024 wymiar\u00f3w\n2. \u2705 Weryfikowa\u0107 wymiar przed indexowaniem\n3. \u2705 Logowa\u0107 wymiary\n4. \u2705 Failowa\u0107 gracefully przy niezgodno\u015bci\n\n**Brak zgodno\u015bci = Indexing nie dzia\u0142a = Dashboard pusty = System broken!**\n\n---\n\n**Dokument:** HELENA_VECTOR_1024_REQUIREMENT.md  \n**Wersja:** 1.0  \n**Data:** 2025-11-04  \n**Status:** \u2705 ACTIVE - OBOWI\u0104ZKOWY\n\n*Helena u\u017cywa 1024-wymiarowych vector\u00f3w dla Qdrant - ZAWSZE!* \ud83c\udfaf\n",
  "indexed_at": "2025-11-04T10:13:05.221728",
  "source": "realtime_watcher"
}