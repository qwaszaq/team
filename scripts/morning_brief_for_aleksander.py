#!/usr/bin/env python3
"""
Morning Brief Agent - Aleksander Edition
========================================

Automatically briefs Aleksander (Orchestrator) after system restart
Provides hot knowledge and context for immediate action
"""

import os
import sys
import json
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
from collections import defaultdict
from typing import Dict, List

PROJECT_ROOT = Path("/Users/artur/coursor-agents-destiny-folder")
DOCS_DIR = PROJECT_ROOT / "docs"
BRIEF_OUTPUT = PROJECT_ROOT / "docs" / "status" / f"MORNING_BRIEF_{datetime.now().strftime('%Y%m%d')}.md"


class AleksanderBriefingAgent:
    """Morning Brief Agent specifically for Aleksander"""
    
    def __init__(self):
        self.now = datetime.now()
        self.brief_content = []
        
    def generate_brief(self):
        """Generate comprehensive brief for Aleksander"""
        
        print("="*80)
        print(" "*20 + "üåÖ MORNING BRIEF FOR ALEKSANDER")
        print(" "*25 + self.now.strftime("%A, %B %d, %Y %H:%M"))
        print("="*80)
        print()
        
        # Build brief content
        self.add_header()
        self.add_critical_alerts()
        self.add_git_activity()
        self.add_pending_tasks()
        self.add_team_status()
        self.add_hot_topics()
        self.add_system_health()
        self.add_recommendations()
        self.add_footer()
        
        # Save brief
        self.save_brief()
        
        # Display summary
        print("\n‚úÖ Brief generated and saved")
        print(f"üìÑ Location: {BRIEF_OUTPUT}")
        print(f"üìä Sections: {len(self.brief_content)}")
        print()
        
        # Show key highlights
        print("üî• KEY HIGHLIGHTS:")
        self.show_highlights()
        
    def add_header(self):
        """Add brief header"""
        
        content = f"""# üåÖ Morning Brief for Aleksander Nowak (Orchestrator)

**Date:** {self.now.strftime('%A, %B %d, %Y')}  
**Time:** {self.now.strftime('%H:%M:%S')}  
**Generated by:** Morning Brief Agent (Automated)

---

## üéØ Executive Summary

Good morning, Aleksander! This is your automated daily brief with hot knowledge and actionable insights.
"""
        self.brief_content.append(content)
        
    def add_critical_alerts(self):
        """Check for critical issues"""
        
        content = "\n## üö® Critical Alerts\n\n"
        alerts = []
        
        # Check Helena tasks
        helena_tasks = PROJECT_ROOT / "helena_tasks"
        if helena_tasks.exists():
            tasks = list(helena_tasks.glob("helena_task_*.md"))
            if len(tasks) > 5:
                alerts.append(f"‚ö†Ô∏è  **{len(tasks)} Helena tasks pending** - Review and prioritize")
                
        # Check realtime queue
        realtime_queue = helena_tasks / "realtime_queue"
        if realtime_queue.exists():
            queued = list(realtime_queue.glob("*.json"))
            if len(queued) > 10:
                alerts.append(f"‚ö†Ô∏è  **{len(queued)} items in realtime queue** - May need processing")
                
        # Check uncommitted changes
        try:
            result = subprocess.run(
                ['git', '-C', str(PROJECT_ROOT), 'status', '--porcelain'],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                changes = len(result.stdout.strip().split('\n'))
                if changes > 50:
                    alerts.append(f"‚ö†Ô∏è  **{changes} uncommitted changes** - Consider committing progress")
        except:
            pass
            
        if alerts:
            for alert in alerts:
                content += f"- {alert}\n"
        else:
            content += "‚úÖ **No critical alerts** - All systems nominal\n"
            
        content += "\n"
        self.brief_content.append(content)
        
        # Print alerts
        print("üö® CRITICAL ALERTS:")
        if alerts:
            for alert in alerts:
                print(f"   {alert}")
        else:
            print("   ‚úÖ No critical alerts")
        print()
        
    def add_git_activity(self):
        """Analyze recent git activity"""
        
        content = "\n## üìä Git Activity (Last 24h)\n\n"
        
        try:
            # Last commit
            result = subprocess.run(
                ['git', '-C', str(PROJECT_ROOT), 'log', '-1', '--pretty=format:%h|%an|%ar|%s'],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0 and result.stdout:
                hash, author, time, message = result.stdout.split('|', 3)
                content += f"**Last commit:** `{hash}` - {message}\n"
                content += f"*By {author}, {time}*\n\n"
                
            # Recent commits
            since_24h = (self.now - timedelta(hours=24)).strftime("%Y-%m-%d %H:%M:%S")
            result = subprocess.run(
                ['git', '-C', str(PROJECT_ROOT), 'log', f'--since={since_24h}', '--oneline'],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                commits = result.stdout.strip().split('\n') if result.stdout.strip() else []
                content += f"**Commits last 24h:** {len(commits)}\n\n"
                
                if commits and len(commits) <= 10:
                    content += "Recent commits:\n"
                    for commit in commits[:10]:
                        content += f"- `{commit}`\n"
                        
            # Current branch
            result = subprocess.run(
                ['git', '-C', str(PROJECT_ROOT), 'branch', '--show-current'],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                branch = result.stdout.strip()
                content += f"\n**Current branch:** `{branch}`\n"
                
        except Exception as e:
            content += f"‚ö†Ô∏è  Could not analyze git: {e}\n"
            
        content += "\n"
        self.brief_content.append(content)
        
    def add_pending_tasks(self):
        """List pending tasks requiring attention"""
        
        content = "\n## üìã Pending Tasks & Actions\n\n"
        
        # Helena tasks
        helena_tasks = PROJECT_ROOT / "helena_tasks"
        if helena_tasks.exists():
            tasks = list(helena_tasks.glob("helena_task_*.md"))
            if tasks:
                content += f"### Helena Tasks ({len(tasks)})\n\n"
                
                # Sort by date
                tasks.sort(key=lambda x: x.stat().st_mtime, reverse=True)
                
                for task in tasks[:10]:
                    mtime = datetime.fromtimestamp(task.stat().st_mtime)
                    age = (self.now - mtime).days
                    age_str = f"{age}d old" if age > 0 else "today"
                    
                    content += f"- `{task.name}` ({age_str})\n"
                    
                if len(tasks) > 10:
                    content += f"\n*... and {len(tasks) - 10} more*\n"
                    
                content += "\n**Action:** Review and assign priorities\n\n"
                
        # Realtime queue
        realtime_queue = helena_tasks / "realtime_queue" if helena_tasks.exists() else None
        if realtime_queue and realtime_queue.exists():
            queued = list(realtime_queue.glob("*.json"))
            if queued:
                content += f"### Realtime Processing Queue ({len(queued)})\n\n"
                content += f"Items waiting for Helena to process.\n\n"
                content += "**Action:** Check if realtime watcher is running\n\n"
                
        self.brief_content.append(content)
        
    def add_team_status(self):
        """Analyze team and agent status"""
        
        content = "\n## üë• Team Status\n\n"
        
        # Check documentation by category
        if DOCS_DIR.exists():
            categories = {}
            
            for category_dir in DOCS_DIR.iterdir():
                if category_dir.is_dir() and not category_dir.name.startswith('.'):
                    files = list(category_dir.glob("*.md"))
                    categories[category_dir.name] = len(files)
                    
            if categories:
                content += "### Documentation by Category\n\n"
                content += "| Category | Documents |\n"
                content += "|----------|----------|\n"
                
                for cat, count in sorted(categories.items(), key=lambda x: x[1], reverse=True):
                    content += f"| {cat} | {count} |\n"
                    
                content += f"\n**Total:** {sum(categories.values())} documents\n\n"
                
        self.brief_content.append(content)
        
    def add_hot_topics(self):
        """Identify what's hot in last 7 days"""
        
        content = "\n## üî• Hot Topics (Last 7 days)\n\n"
        
        hot_keywords = defaultdict(int)
        recent_docs = []
        
        # Scan recent docs
        if DOCS_DIR.exists():
            for category_dir in DOCS_DIR.iterdir():
                if not category_dir.is_dir():
                    continue
                    
                for doc in category_dir.glob("*.md"):
                    try:
                        mtime = datetime.fromtimestamp(doc.stat().st_mtime)
                        if (self.now - mtime).days < 7:
                            recent_docs.append((doc, mtime))
                            
                            # Analyze content
                            doc_content = doc.read_text(encoding='utf-8').upper()
                            
                            topics = {
                                'HELENA': 'Helena (Data Infrastructure)',
                                'ALEKSANDER': 'Aleksander (Orchestration)',
                                'VERIFICATION': 'Verification System',
                                'DATABASE': 'Database Operations',
                                'PROTOCOL': 'Protocols & Processes',
                                'TEAM': 'Team Collaboration',
                                'ANALYTICAL': 'Analytical Team',
                                'REALTIME': 'Real-Time Processing',
                                'MONITORING': 'Monitoring Systems',
                                'AGENT': 'Agent Development'
                            }
                            
                            for keyword, label in topics.items():
                                if keyword in doc_content:
                                    hot_keywords[label] += 1
                                    
                    except:
                        pass
                        
        # Display hot topics
        if hot_keywords:
            sorted_topics = sorted(hot_keywords.items(), key=lambda x: x[1], reverse=True)
            
            content += "Most active areas:\n\n"
            for topic, count in sorted_topics[:10]:
                heat = "üî•" * min((count // 10) + 1, 5)
                content += f"- **{topic}**: {heat} ({count} mentions)\n"
                
            content += "\n"
            
        # Recent documents
        if recent_docs:
            recent_docs.sort(key=lambda x: x[1], reverse=True)
            content += f"\n### Recently Modified ({len(recent_docs)} docs)\n\n"
            
            for doc, mtime in recent_docs[:10]:
                rel_path = doc.relative_to(DOCS_DIR)
                days = (self.now - mtime).days
                time_str = "today" if days == 0 else f"{days}d ago"
                content += f"- `{rel_path}` ({time_str})\n"
                
            content += "\n"
            
        self.brief_content.append(content)
        
    def add_system_health(self):
        """Check system health indicators"""
        
        content = "\n## üè• System Health\n\n"
        
        health_checks = []
        
        # Check if key directories exist
        key_dirs = [
            (DOCS_DIR, "Documentation structure"),
            (PROJECT_ROOT / "scripts", "Scripts directory"),
            (PROJECT_ROOT / "agents", "Agents directory"),
            (PROJECT_ROOT / "sql", "SQL scripts")
        ]
        
        for dir_path, desc in key_dirs:
            if dir_path.exists():
                health_checks.append(f"‚úÖ {desc}")
            else:
                health_checks.append(f"‚ùå {desc} - MISSING")
                
        # Check if watcher is running
        try:
            result = subprocess.run(
                ['ps', 'aux'],
                capture_output=True,
                text=True
            )
            
            if 'realtime_md_watcher' in result.stdout:
                health_checks.append("‚úÖ Realtime watcher is running")
            else:
                health_checks.append("‚ö†Ô∏è  Realtime watcher not running - Start with ./start_realtime_helena.sh")
        except:
            pass
            
        for check in health_checks:
            content += f"{check}\n"
            
        content += "\n"
        self.brief_content.append(content)
        
    def add_recommendations(self):
        """Provide actionable recommendations"""
        
        content = "\n## üí° Recommendations for Today\n\n"
        
        recommendations = []
        
        # Check Helena tasks
        helena_tasks = PROJECT_ROOT / "helena_tasks"
        if helena_tasks.exists():
            tasks = list(helena_tasks.glob("helena_task_*.md"))
            if tasks:
                recommendations.append({
                    'priority': 'HIGH',
                    'action': f'Review and prioritize {len(tasks)} Helena tasks',
                    'reason': 'Knowledge propagation is pending'
                })
                
        # Check uncommitted changes
        try:
            result = subprocess.run(
                ['git', '-C', str(PROJECT_ROOT), 'status', '--porcelain'],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                changes = len(result.stdout.strip().split('\n'))
                if changes > 20:
                    recommendations.append({
                        'priority': 'MEDIUM',
                        'action': f'Commit {changes} pending changes',
                        'reason': 'Good practice to commit progress regularly'
                    })
        except:
            pass
            
        # Check realtime watcher
        try:
            result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
            if 'realtime_md_watcher' not in result.stdout:
                recommendations.append({
                    'priority': 'LOW',
                    'action': 'Start realtime watcher',
                    'reason': 'Enables instant processing of new documentation'
                })
        except:
            pass
            
        # Display recommendations
        if recommendations:
            # Sort by priority
            priority_order = {'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
            recommendations.sort(key=lambda x: priority_order.get(x['priority'], 99))
            
            for i, rec in enumerate(recommendations, 1):
                emoji = {'HIGH': 'üî¥', 'MEDIUM': 'üü°', 'LOW': 'üü¢'}.get(rec['priority'], '‚ö™')
                content += f"{i}. {emoji} **{rec['priority']}**: {rec['action']}\n"
                content += f"   *Why:* {rec['reason']}\n\n"
        else:
            content += "‚úÖ No specific recommendations - System is healthy!\n\n"
            content += "**Suggested activities:**\n"
            content += "- Review documentation index: `docs/INDEX.md`\n"
            content += "- Check team status in `docs/team/`\n"
            content += "- Plan next sprint items\n\n"
            
        self.brief_content.append(content)
        
    def add_footer(self):
        """Add brief footer"""
        
        content = f"""
---

## üìö Quick Reference

- **Documentation Index:** [`docs/INDEX.md`](docs/INDEX.md)
- **Morning Brief Script:** `scripts/morning_brief.py`
- **Realtime Watcher:** `./start_realtime_helena.sh`
- **Helena Tasks:** `helena_tasks/`

---

**Generated:** {self.now.strftime('%Y-%m-%d %H:%M:%S')}  
**System:** Morning Brief Agent (Automated)  
**For:** Aleksander Nowak (Orchestrator)

*This brief is automatically generated daily. Knowledge is fresh and hot.* ‚òï
"""
        self.brief_content.append(content)
        
    def save_brief(self):
        """Save brief to file"""
        
        # Ensure directory exists
        BRIEF_OUTPUT.parent.mkdir(parents=True, exist_ok=True)
        
        # Combine all content
        full_content = "\n".join(self.brief_content)
        
        # Save
        BRIEF_OUTPUT.write_text(full_content)
        
    def show_highlights(self):
        """Show key highlights in console"""
        
        # Check Helena tasks
        helena_tasks = PROJECT_ROOT / "helena_tasks"
        if helena_tasks.exists():
            tasks = list(helena_tasks.glob("helena_task_*.md"))
            if tasks:
                print(f"   üìã {len(tasks)} Helena tasks pending")
                
        # Check recent activity
        try:
            since_24h = (self.now - timedelta(hours=24)).strftime("%Y-%m-%d %H:%M:%S")
            result = subprocess.run(
                ['git', '-C', str(PROJECT_ROOT), 'log', f'--since={since_24h}', '--oneline'],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                commits = result.stdout.strip().split('\n') if result.stdout.strip() else []
                if commits:
                    print(f"   üìä {len(commits)} commits in last 24h")
        except:
            pass
            
        print(f"\nüìÑ Full brief saved to: docs/status/MORNING_BRIEF_{datetime.now().strftime('%Y%m%d')}.md")
        print()


def main():
    """Main entry point"""
    
    agent = AleksanderBriefingAgent()
    agent.generate_brief()


if __name__ == "__main__":
    main()
